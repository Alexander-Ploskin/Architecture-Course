# Task 1 — CLI Architecture

## Команда
1. [Александр Плоскин](https://github.com/Alexander-Ploskin)
2. [Станислав Мищенко](https://github.com/mi-sts)

## Условие задачи

В командах по два-три человека спроектировать простой интерпретатор командной строки, поддерживающий команды:
 - `cat [FILE]` — вывести на экран содержимое файла;
 - `echo` — вывести на экран свой аргумент (или аргументы);
 - `wc [FILE]` — вывести количество строк, слов и байт в файле;
 - `pwd` — распечатать текущую директорию;
 - `exit` — выйти из интерпретатора.

При этом должны поддерживаться:
 - динарные и двойные кавычки (full and weak quoting);
 - окружение (команды вида “имя=значение”), оператор `$`;
 - вызов внешней программы, если введено что-то, чего интерпретатор не знает;
 - пайплайны (оператор «`|`»).

Примеры
```cmd
echo "Hello, world!"
Hello, world!

FILE=example.txt
cat $FILE
Some example text

cat example.txt | wc
1 3 18

echo 123 | wc
1 1 3

x=ex
y=it
$x$y
```

Решение должно удовлетворять следующим нефункциональным требованиям:
 - легко добавлять новые команды;
 - чёткое разграничение ответственности между элементами архитектуры;
 - это не должен быть просто клубок классов, требуется некая компонентная структура;
 - наличие словесного архитектурного описания.

## Диаграмма классов
<img src="./ClassDiagram.svg">

## Описание

### Client
Интерфейс `IClient` предоставляет методы для взаимодействия с пользователем системы. Реализация по умолчанию `CliClient` представляет из себя консольный интерфейс приложения.

### Interpreter
Класс `Interpreter` играет роль контроллера системы. Он получает пользовательский ввод в виде строки, содержащей команды, аргументы и символы пайплайна (`|`) от реализации `IClient`. С помощью `PipelineParser` строка ввода разделяется на отдельные части пайплайна. Затем каждая часть пайплайна проходит итеративный процесс парсинга в данные для создания команд, осуществляемый `CommandParser`. Эти данные передаются в `CommandMatcher`, который находит соответствующий экземпляр команды. Результаты выполнения команды либо отображаются пользователю через `IClient`, либо передаются дальше по пайплайну. В случае возникновения ошибки при парсинге команды или ее выполнении, текущий пайплайн прерывается, и пользователю выводится сообщение об ошибке.

### CommandParser
Класс `CommandParser` выполняет разбор строки согласно синтаксису языка инструмента. Его результатом является структура `CommandFactoryData`, содержащая имя команды и ее аргументы. Кроме того, класс `CommandParser` осуществляет подстановку значений переменных окружения. Этот класс реализован с использованием шаблона [Состояние](https://www.geeksforgeeks.org/state-design-pattern/), где каждая реализация `IParserState` соответствует состоянию конечного автомата, выполняющего разбор языка. Класс `CommandParserContext` представляет контекст разбора строки.

### CommandMatcher
Класс `CommandMatcher` используется для сопоставления строк с названиями команд (`commandName`) с соответствующими фабриками (`ICommandFactory`), которые создают экземпляры соответствующих типов команд. Фабрики наследуются от `ICommandFactory`. Класс `CommandMatcher` передает аргументы команды фабрике для создания экземпляра команды.
У каждой фабрики, наследующей `ICommandFactory`, есть статический метод `getCommandName()`, результат которого должен совпадать с искомой строкой (`commandName`). Если ни одна из существующих команд не соответствует искомой строке, то используется `ExternalCommandFactory`. Она создает `ExternalCommand`, который вызывает внешнюю программу.

### ICommand
Интерфейс `ICommand` представляет метод исполнения команды `execute`. Он возвращает монадический тип, который соответствует либо результату вычисления команды, либо ошибке. `AssignVariableCommand` представляет команду вида **“имя=значение”**, которая реализована так же, как остальные команды в системе. `CommandParser` сопоставляет строке **“x=exit”** название команды **“assingn”** и аргументы **“x”, “exit”**. Команда **“exit”** реализована на уровне класса `Interpreter`, так как требует взаимодействия с состоянием приложения.

### IEnvironment
Интерфейс `IEnvironment` предоставляет зависимость от внешнего окружения, включая работу с файловой системой и переменными окружения. Его реализации могут зависеть от конкретных ОС.

### Как добавить новую команду?
1. Реализовать интерфейс `ICommand` с методом, который соответствует действию команды.
2. Реализовать интерфейс `ICommandFactory` с методом `getCommandName`, который возвращает название команды в CLI, и метод `create`, создающий команду с аргументами.

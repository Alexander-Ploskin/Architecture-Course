# Task 1 — CLI Tool Architecture

## Команда
1. [Александр Плоскин](https://github.com/Alexander-Ploskin)
2. [Станислав Мищенко](https://github.com/mi-sts)

## Диаграмма
<img src="./ClassDiagram.svg">

## Описание

### Client
Интерфейс `IClient` предоставляет методы для взаимодействия с пользователем системы. Реализация по умолчанию `CliClient` представляет из себя консольный интерфейс приложения.

### Interpreter
Класс `Interpreter` играет роль контроллера системы. Он получает пользовательский ввод в виде строки, содержащей команды, аргументы и символы пайплайна (`|`) от реализации `IClient`. С помощью `PipelineParser` строка ввода разделяется на отдельные части пайплайна. Затем каждая часть пайплайна проходит итеративный процесс парсинга в данные для создания команд, осуществляемый `CommandParser`. Эти данные передаются в `CommandMatcher`, который находит соответствующий экземпляр команды. Результаты выполнения команды либо отображаются пользователю через `IClient`, либо передаются дальше по пайплайну. В случае возникновения ошибки при парсинге команды или ее выполнении, текущий пайплайн прерывается, и пользователю выводится сообщение об ошибке.

### CommandParser
Класс `CommandParser` выполняет разбор строки согласно синтаксису языка инструмента. Его результатом является структура `CommandFactoryData`, содержащая имя команды и ее аргументы. Кроме того, класс `CommandParser` осуществляет подстановку значений переменных окружения. Этот класс реализован с использованием шаблона [Состояние](https://www.geeksforgeeks.org/state-design-pattern/), где каждая реализация `IParserState` соответствует состоянию конечного автомата, выполняющего разбор языка. Класс `CommandParserContext` представляет контекст разбора строки.

### CommandMatcher
Класс `CommandMatcher` используется для сопоставления строк с названиями команд (`commandName`) с соответствующими фабриками (`ICommandFactory`), которые создают экземпляры соответствующих типов команд. Фабрики наследуются от `ICommandFactory`. Класс `CommandMatcher` передает аргументы команды фабрике для создания экземпляра команды.
У каждой фабрики, наследующей `ICommandFactory`, есть статический метод `getCommandName()`, результат которого должен совпадать с искомой строкой (`commandName`). Если ни одна из существующих команд не соответствует искомой строке, то используется `ExternalCommandFactory`. Она создает `ExternalCommand`, который вызывает внешнюю программу.

### ICommand
Интерфейс `ICommand` представляет метод исполнения команды `execute`. Он возвращает монадический тип, который соответствует либо результату вычисления команды, либо ошибке. `AssignVariableCommand` представляет команду вида **“имя=значение”**, которая реализована так же, как остальные команды в системе. `CommandParser` сопоставляет строке **“x=exit”** название команды **“assingn”** и аргументы **“x”, “exit”**. Команда **“exit”** реализована на уровне класса `Interpreter`, так как требует взаимодействия с состоянием приложения.

### IEnvironment
Интерфейс `IEnvironment` предоставляет зависимость от внешнего окружения, включая работу с файловой системой и переменными окружения. Его реализации могут зависеть от конкретных ОС.

### Как добавить новую команду?
1. Реализовать интерфейс `ICommand` с методом, который соответствует действию команды.
2. Реализовать интерфейс `ICommandFactory` с методом `getCommandName`, который возвращает название команды в CLI, и метод `create`, создающий команду с аргументами.
